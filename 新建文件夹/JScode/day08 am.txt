正课：
1. *错误处理
2. ****函数对象
    *****闭包

1. *错误处理
   错误：导致程序无法正常执行的异常状态
         发生错误，程序立刻退出
   错误对象：Error  封装错误信息的对象，在发生错误时自动创建
       6种：
       ReferenceError:找不到对象时
       TypeError:错误的使用了类型或对象的方法时
       RangeError:使用内置对象的方法时，参数超范围
       SyntaxError:语法写错了
       EvalError:错误的使用了Eval   
       URIError:URI错误

   错误处理：即使程序发生错误，也保证不异常中断的机制

   如何错误处理：
   try{
       可能发生错误的代码
   }catch(err){
       只有发生错误时才执行的代码――错误处理代码
   }[finally{
       无论是否出错，肯定都要执行的代码――善后工作(保存，释放
   }]

   问题：使用try包裹的代码，即使不出错，效率也比不用try包裹的代码低。
   建议：在try块中，尽量少的包含可能出错的代码。
   优化：尽量使用if判断代替try catch
   无法提前预知错误类型的错误，必须用try catch捕获。

   抛出自定义错误：
   何时：如果函数的定义者，需要告知调用者使用过程中的错误
   如何：throw new Error("参数必须是数字！");

2. ****函数对象：
   js中的函数也是一个对象，封装了一项任务的步骤清单代码段，起一个名字。
   函数名其实只是引用函数对象的一个变量

   arguments对象：接收所有传入函数的参数值的*类数组对象*
                  默认所有函数都会自动创建，直接可用。
     类数组对象：长得像数组的*对象*,不是数组类型的实例(对象)
         arguments instanceof Array -->false
         [] instanceof Array --> true
         obj instanceof 类型名:专门判断obj是否是指定类型的实例
  ***鄙视题：类数组对象 vs 数组: 类型不相同
          相同点: 
	     都可用下标访问每个元素
             都有length属性，记录元素个数
          不同点：
             数组对象的类型是Array，类数组对象的类型是Object
             不能直接调用数组API！
        其实类数组对象可转为标准数组对象：
          arguments=Array.prototype.slice.call(arguments);
   ***重载overload: 程序中可同时定义多个同名，但不同参数的函数
            调用时，可自动根据传入的参数不同，调用不同的函数
      优点：方便调用！减少记忆的API个数
   js在语法上不支持重载！但可用arguments模拟实现重载效果！

   自定义参数变量的作用：1. 提醒调用者，如何正确使用函数
                         2. 使用比arguments简单
   总结：函数尽量定义参数

   创建函数对象：3种：
     1. 声明方式创建：
        ***只有以声明方式创建的函数才能被hoist（声明提前）
	function 函数名(参数列表){函数体;return 返回值};
     2. 函数直接量：
        var 函数名=function (参数列表){函数体;return 返回值};
     3. 实例化对象: 参数名和函数体都是字符串
        var 函数名=new Function(
	     "参数名1","参数名2",...,"函数体; return 返回值");
   鄙视题：js中创建函数的方式正确的是
     
   

















