正课：
1. ***面向对象：
   ****原型和原型链
   *****继承

1. ****原型和原型链:
     原型：专门保存所有子对象共有属性值和方法的对象
           每个函数对象都有一个prototype属性，指向一个原型对象
           在创建新子对象时，会自动设置子对象的原型属性(__proto__)为构造函数的原型对象。――子对象继承构造函数的原型
     何时使用：今后只要所有子对象共有的成员值，都要保存在构造函数的原型对象中。――一次定义，反复使用
      优点：1. 节省内存空间
            2. 一次修改，处处生效――便于维护！

     new：4步: 
        1. 创建空对象: new Object()
        2. 使用新对象，调用构造函数
             (new Object()).构造函数();//this-->刚创建的空对象
        3. 设置新对象的__proto__指向构造函数的prototype对象
        4. 将新对象地址，保存到等号左边的变量中

    继承：子对象可以直接使用父对象中的成员。
    
    所有对象都有__proto__属性
    原型链：所有对象的__proto__自底向上连续继承形成的链式结构
            访问一个对象的成员时，先在对象本地查找。
            如果找不到会延原型链向父对象查找，直到找到为止。

    原型相关API：
      1. 获得原型对象: 2种：
         1. 从构造函数获得原型对象: 
              构造函数名.prototype
         2. 从子对象获得父级原型对象:
              子对象.__proto__――有兼容性问题，不建议使用
              var proto=Object.getPrototypeOf(子对象)
                               get 子对象 的 prototype
         prototype vs __proto__
          相同: 其实都指向同一个原型对象
          不同: prototype,属于构造函数
                __proto__,属于子对象
   
      2. 判断父对象是否在子对象的原型链上:
          父对象.isPrototypeOf(子对象) 
          父对象 是 子对象 的 prototype吗？
          如果父对象在原型链上，就返回true，否则返回false
          强调：不仅找直接父对象，且可在整个原型链上查找。
          何时使用：专门用于判断子对象的类型
          比如: 判断一个对象是否是数组: 
            反例: typeof({})  typeof([]) 都返回object
                  Array.prototype.isPrototypeOf({}) false
                  Array.prototype.isPrototypeOf([]) true

      3. 自有属性和共有属性：
         自有属性: 直接保存在对象本地的属性
         共有属性: 保存在原型对象中，所有子对象共有的属性

         如何判断一个属性是否可用：解决浏览器兼容性问题
           1. in关键字："属性名" in 对象
                在对象的*原型链*上查找指定"属性名"
                找到，返回true，否则返回false
           2. 判断对象的属性是否有效：
                if(对象.属性名===undefined)

         解决浏览器兼容性问题：看课堂练习

         精确判断一个属性是自有还是共有:
           1. 判断自有: obj.hasOwnProperty("属性名")
                 判断"属性名"是否是obj对象的自有属性
                 如果是，返回true，否则返回false
           2. 判断共有: 自己没有，但是原型链上有
          if(!obj.hasOwnProperty("属性名")&&"属性名" in obj)
     4. 删除对象的属性：delete 对象.属性
          只能删除自有属性，不允许删除共有属性

     5. 如何修改原型对象中的属性：
          共有*只能*通过原型对象修改！
          Student.prototype.className="六年级2班" 正确
          试图通过子对象修改共有属性，会在子对象本地创建共有属性的副本。
          lilei.className="六年级2班" 在李雷本次创建className
          从此李雷和共有className再无关系。

4. *****继承：
     面向对象三大特点：封装 继承 多态
         封装：将属性和方法集中定义在一个对象中
         继承：父对象中的成员，子对象可直接使用
         多态：统一个事物，在不同情况下表现出不同的状态
               重载overload   重写override
     重写：子对象觉得父对象的方法不好用！可在本地自定义同名方法，覆盖父对象的方法。

     实现自定义继承关系：3种
      为什么继承: 代码重用！
         修改子对象的__proto__引用的对象
         js中的一切继承关系都是由原型(__proto__)属性实现的
     1. 一个对象，只继承自另一个对象：
        Object.setPrototypeOf(子对象,父对象)
          set 子对象 的 原型 指向 父对象
                         继承
     2. 修改构造函数的原型对象：创建新对象之前修改
          保证之后创建的所有子对象都继承同一个新父对象
          构造函数.prototype=新父对象
     3. 继承原型的同时，继承结构: 最像Java的继承
          2步：
          1. 将子类型的原型对象继承父类型的原型对象
          2. 调用父类型构造函数,
             同时强行指定父类型构造函数的this！
             函数.call(this的值,参数1,...) 
             call在调用函数时，临时更换EC中的this引用的对象          
          
 







